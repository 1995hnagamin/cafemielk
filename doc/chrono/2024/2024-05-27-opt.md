2024-05-27 `cross3d` の高速化
========

## 環境

```
Gauche scheme shell, version 0.9.15-p1 [utf-8,pthreads], x86_64-apple-darwin21.6.0
(version "0.9.15-p1")
(command "gosh")
(scheme.id gauche)
(languages scheme r5rs r7rs)
(encodings utf-8)
(website "https://practical-scheme.net/gauche")
(build.platform "x86_64-apple-darwin21.6.0")
(build.configure "--prefix=/----" "LDFLAGS=-L/usr/local/opt/bison/lib")
(scheme.path "/----/share/gauche-0.98/site/lib" "/----/share/gauche-0.98/0.9.15-p1/lib")
(threads pthreads)
(gauche.net.tls mbedtls)
```


## 高速化前

現状の `cross3d` の定義は以下の通り。
`main` ブランチでは `define-inline` によるインライン化を行っていないが、比較のためにここではインライン化しておく。

```scheme
;;
;; cafemielk.util
;;

(define-inline (vec3d-tabulate func)
  (vector-map (lambda (indices) (apply func indices))
              #((0 1 2) (1 2 0) (2 0 1))))

(define-inline (cross3d u v)
  (define (u_ i) (vector-ref u i))
  (define (v_ i) (vector-ref v i))
  (vec3d-tabulate
   (lambda (i j k)
     (- (* (u_ j) (v_ k)) (* (u_ k) (v_ j))))))
```

逆アセンブル結果は以下の通り。

```
gosh$ (disasm (^[] (cross3d #(3 141 5) #(92 65 35))))
CLOSURE #<closure (#f)>
=== main_code (name=#f, cc=0x102f19de0, codevec=0x101564240, size=8, const=2 stack=9):
signatureInfo: ((#f))
     0 LREF0-PUSH               ; #:G151
     1 LOCAL-ENV(1)             ; (vec3d-tabulate (lambda (i j k) (- (* (u
     2 LREF11-PUSH              ; #:G152
     3 CONST-PUSH #((0 1 2) (1 2 0) (2 0 1))
     5 GREF-TAIL-CALL(2) #<identifier cafemielk.util#vector-map.13536c0>; (vector-map (lambda (indices) (apply fun
     7 RET
LIFTED CLOSURE #<closure ((#f cross3d) i j k)>
=== main_code (name=(#f cross3d), cc=0x102f19ea0, codevec=0x10311da80, size=23, const=2 stack=3):
signatureInfo: (((#f cross3d) i j k))
     0 CONST-PUSH #(3 141 5)
     2 LREF1                    ; j
     3 VEC-REF                  ; (vector-ref u i)
     4 PUSH
     5 CONST-PUSH #(92 65 35)
     7 LREF0                    ; k
     8 VEC-REF                  ; (vector-ref v i)
     9 NUMMUL2                  ; (* (u_ j) (v_ k))
    10 PUSH
    11 CONST-PUSH #(3 141 5)
    13 LREF0                    ; k
    14 VEC-REF                  ; (vector-ref u i)
    15 PUSH
    16 CONST-PUSH #(92 65 35)
    18 LREF1                    ; j
    19 VEC-REF                  ; (vector-ref v i)
    20 NUMMUL2                  ; (* (u_ k) (v_ j))
    21 NUMSUB2                  ; (- (* (u_ j) (v_ k)) (* (u_ k) (v_ j)))
    22 RET
LIFTED CLOSURE #<closure ((#f #:G152) indices)>
=== main_code (name=(#f #:G152), cc=0x102f19f60, codevec=0x102fabf60, size=4, const=0 stack=2):
signatureInfo: (((#f #:G152) indices))
     0 LREF10-PUSH              ; #:G151
     1 LREF0                    ; indices
     2 TAIL-APPLY(2)            ; (apply func indices)
     3 RET
```

5行目に `GREF-TAIL-CALL(2)` とあり、多分 `vector-map` が呼ばれている。
`(vector-map proc vec)` という呼び出しにおいて `proc` と `vec` が両方コンパイル時に既知なので、直接ベクトルの各成分を計算するように書き換えてほしい。
本当は定数（`#(4610 355 -12777)`）が出力されてほしい。

ベンチマークの結果は以下の通り。

```
;; (use gauche.time)
gosh$ (time-this 1000000 (^[] (cross3d #(3 141 5) #(92 65 35))))
#<time-result 1000000 times/  1.094 real/  1.220 user/  0.010 sys>
```

剛性行列を計算するときの外積の計算回数は結構多い（はず）ので気になる。

## 高速化後

`vec3d-tabulate` は3引数関数を受け取ってベクトルの各成分を計算する。
これを使うのをやめて、マクロで直接ベクトルを生成するように書き換える。

```scheme
;; マクロ定義を `cross3d` の前に書かないと動かない
(define-syntax vec3d-tab
  (syntax-rules ()
    ((_ (i j k) expr)
     (let-syntax
         ((component (syntax-rules ()
                       ((_ i j k) expr))))
       (vector (component 0 1 2)
               (component 1 2 0)
               (component 2 0 1))))))

(define-inline (cross3d u v)
  (define (u_ i) (vector-ref u i))
  (define (v_ i) (vector-ref v i))
  (vec3d-tab
   (i i+1 i+2)
   (- (* (u_ i+1) (v_ i+2)) (* (u_ i+2) (v_ i+1)))))
```

マクロ `vec3d-tab` の中でローカルのマクロ `component` を作っている。
外積以外の処理にも使えるようにこのような一般的な形で定義しておく。例：

```
(vec3d-tab (i i+1 i+2) (- (vector-ref u i+2) (vector-ref v i)))
;; => (vector (- (vector-ref u 2) (vector-ref v 0))
;;            (- (vector-ref u 0) (vector-ref v 1))
;;            (- (vector-ref u 1) (vector-ref v 2)))
```

逆アセンブル結果は以下の通り。
引数が定数であることを見抜いて最初から `#(4610 355 -12777)` を返すようになった。

```
gosh$ (disasm (^[] (cross3d #(3 141 5) #(92 65 35))))
CLOSURE #<closure (#f)>
=== main_code (name=#f, cc=0x102e9dc60, codevec=0x1032f3870, size=5, const=0 stack=2):
signatureInfo: ((#f))
     0 CONSTI-PUSH(4610)
     1 CONSTI-PUSH(355)
     2 CONSTI(-12777)
     3 VEC(3)                   ; (vector (component 0 1 2) (component 1 2
     4 RET
```

ベンチマークの結果は以下の通り。
約12.6倍速くなった。

```
gosh$ (time-this 1000000 (^[] (cross3d #(3 141 5) #(92 65 35))))
#<time-result 1000000 times/  0.087 real/  0.150 user/  0.000 sys>
```

--------
Author: hnagamin.
Permanent ID of this document: `6042855eb32fde0cad288e6f5ceeb87bdc47dd60`.
Date: 2024-05-27.
